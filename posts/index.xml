<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Raas Ahsan</title><link>http://raasahsan.com/posts/</link><description>Recent content in Posts on Raas Ahsan</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 28 Feb 2021 19:00:00 -0500</lastBuildDate><atom:link href="http://raasahsan.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Typelevel Church Numerals in Scala 3</title><link>http://raasahsan.com/posts/typelevel-church-numerals-in-scala-3/</link><pubDate>Sun, 28 Feb 2021 19:00:00 -0500</pubDate><guid>http://raasahsan.com/posts/typelevel-church-numerals-in-scala-3/</guid><description>Modeling church numerals as functions in most languages is straightforward. Scala&amp;rsquo;s type system is powerful enough that we can represent them and express computation with them directly in the type system!
The definitions in Scala follow immediately from the definitions in the untyped lambda calculus; functions in the latter correspond to typelevel functions in the former.
object ChurchNumerals extends App { type zero[s[_], z] = z type succ[m[s[_], z], s[_], z] = s[m[s, z]] type one[s[_], z] = succ[zero, s, z] type two[s[_], z] = succ[one, s, z] type plus = [m[_[_], _]] =&amp;gt;&amp;gt; [n[_[_], _]] =&amp;gt;&amp;gt; [s[_], z] =&amp;gt;&amp;gt; m[s, n[s, z]] type +[m[_[_], _], n[_[_], _]] = [s[_], z] =&amp;gt;&amp;gt; plus[m][n][s, z] type times = [m[_[_], _]] =&amp;gt;&amp;gt; [n[_[_], _]] =&amp;gt;&amp;gt; [s[_], z] =&amp;gt;&amp;gt; m[[z0] =&amp;gt;&amp;gt; n[s, z0], z] type *[m[_[_], _], n[_[_], _]] = [s[_], z] =&amp;gt;&amp;gt; times[m][n][s, z] // use typeclasses to fold over the type structure trait Nat[T]: def real: Int trait Succ[T] trait Zero given natForSucc[T](using N: Nat[T]): Nat[Succ[T]] with override def real: Int = N.</description></item><item><title>Productivity in Type Systems</title><link>http://raasahsan.com/posts/productivity-in-type-systems/</link><pubDate>Sat, 30 Jan 2021 19:00:00 -0500</pubDate><guid>http://raasahsan.com/posts/productivity-in-type-systems/</guid><description>One of the commonly cited drawbacks of type systems is that they can inhibit productivity. I think this depends on your definition of productivity. I can think of two:
To write the smallest amount of code in the shortest amount of time To consistently produce working and bug-free code in such a way that it scales as the codebase and team grow over time. The presence of a type system could certainly hurt productivity in the first case, because languages with type systems often need to be supported by compilers and build tools.</description></item><item><title>Effective Fallbacks</title><link>http://raasahsan.com/posts/effective-fallbacks/</link><pubDate>Sat, 08 Aug 2020 20:00:00 -0500</pubDate><guid>http://raasahsan.com/posts/effective-fallbacks/</guid><description>Faults in distributed systems are inherently inevitable, and so as system designers, we make an effort to build resilience mechanisms into our systems to protect users of our services from observing those faults. This idea is captured by the notion of fault tolerance. A system is fault tolerant with respect to a domain of faults if it continues to operate normally even in the presence of those faults.
Fault tolerance can often be costly, difficult or impossible to implement, so many systems opt to achieve a weaker form of fault tolerance known as graceful degradation.</description></item></channel></rss>